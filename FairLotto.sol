//SPDX-License-Identifier: GPL-3.0

pragma solidity ^0.8.0;

//import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";
import "./VRFConsumerBase.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";


contract FairLotto is VRFConsumerBase, Ownable {

    bytes32 internal keyHash; // chainlink
    uint internal fee; // chainlink
    uint internal randomResult;     // chainlink
    mapping(address => uint[][]) tickets; // tickets per address
    mapping(address => uint[][]) winningTickets;    // list of winning tickets per address
    address lottoNftAddress;        // NFT free to play
    uint internal gamePrice;        // 2000000000000000000
    uint internal gameFee;          // 100000000000000000
    uint internal totalGameFee;     // Total fee cumulated between draws
    uint lotteryType;               // Lottery range
    uint ticketPrice = gamePrice + gameFee; // self explanatory
    uint weekPrize;                 // Total of gamePrice cumulated between draws
    uint[6] drawnNumbers;           // Winning numbers for the last draw
    uint[6] internal randomNum;     // Random number generated by the chainlink network
    uint firstPrize;                // 6 correct numbers
    uint secondPrize;               // 5 correct numbers
    uint thirdPrize;                // 4 correct numbers
    uint firstPrizeWinners;
    uint secondPrizeWinners;
    uint thirdPrizeWinners;
    // uint drawTime;                  // still working on it
    bool gamePaused = false;        // game will be paused one hour before draw

    /**
     * Constructor inherits VRFConsumerBase
     * 
     * Network: Polygon (Matic) Mumbai Testnet
     * Chainlink VRF Coordinator address: 0x8C7382F9D8f56b33781fE506E897a4F1e2d17255
     * LINK token address:                0x326C977E6efc84E512bB9C30f76E30c160eD06FB
     * Key Hash:  0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4
     */
    constructor(uint _gamePrice, uint _gameFee, uint _lotteryType) 
        VRFConsumerBase(
            0x8C7382F9D8f56b33781fE506E897a4F1e2d17255, // VRF Coordinator
            0x326C977E6efc84E512bB9C30f76E30c160eD06FB  // LINK Token
        )
    {
        keyHash = 0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4;
        fee = 0.0001 * 10 ** 18; // 0.0001 LINK (Varies by network)
        gamePrice = _gamePrice;
        gameFee = _gameFee;
        lotteryType = _lotteryType;
        lottoNftAddress = (0xcd3f439F0e66f0373d1F8724afce0a65Db6D83b4); // SmokingMonkey contract address. To be changed with lotto nft address
    }

    //Chainlink
    function getRandomNumber() public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK - fill contract with faucet");
        return requestRandomness(keyHash, fee);
    }

    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {
        randomResult = randomness;
    }

    function expand(uint256 randomValue, uint256 n) internal pure returns (uint256[] memory expandedValues) {
        expandedValues = new uint256[](n);
        for (uint256 i = 0; i < n; i++) {
            expandedValues[i] = (uint256(keccak256(abi.encode(randomValue, i))) % 49) + 1;
        }
        return expandedValues;
    }
    // end of chainlink

    // Public

    function playFreeFairLottery(
        uint256 _nr1, 
        uint256 _nr2, 
        uint256 _nr3, 
        uint256 _nr4, 
        uint256 _nr5, 
        uint256 _nr6
        ) public payable
    {
        require(!gamePaused, "The game is paused");     // Check if game is paused
        IERC721 token = IERC721(lottoNftAddress);       // Only FairLotto NFT owners can play at a preferential price
        uint256 smAmmount = token.balanceOf(msg.sender);    
        require(smAmmount >=1, "You don't own SM NFTs!");
        require(msg.value >= gameFee, "Insufficient funds!");
        require((_nr1 < 50) && (_nr1 > 0) && (_nr2 < 50) && (_nr2 > 0) && (_nr3 < 50) && (_nr3 > 0) && (_nr4 < 50) && (_nr4 > 0) && (_nr5 < 50) && (_nr5 > 0) && (_nr6 < 50) && (_nr6 > 0), "You can pick 6 numbers from 1 to 49.");
        totalGameFee += gameFee;
        tickets[msg.sender].push([_nr1, _nr2, _nr3, _nr4, _nr5, _nr6]);
    }

    function playFairLottery(
        uint256 _nr1, 
        uint256 _nr2, 
        uint256 _nr3, 
        uint256 _nr4, 
        uint256 _nr5, 
        uint256 _nr6
        ) public payable 
    {
        require(!gamePaused, "The game is paused");
        require(msg.value >= ticketPrice, "Insufficient funds!");
        require((_nr1 < 50) && (_nr1 > 0) && (_nr2 < 50) && (_nr2 > 0) && (_nr3 < 50) && (_nr3 > 0) && (_nr4 < 50) && (_nr4 > 0) && (_nr5 < 50) && (_nr5 > 0) && (_nr6 < 50) && (_nr6 > 0), "You can pick 6 numbers from 1 to 49.");
        totalGameFee += gameFee; 
        weekPrize += gamePrice;
        setPrizes();
        tickets[msg.sender].push([_nr1, _nr2, _nr3, _nr4, _nr5, _nr6]);
    }

    function getFirstPrize() public view returns(uint256){
        return(firstPrize);
    }

     function getSecondPrize() public view returns(uint256){
        return(secondPrize);
    }

     function getThirdPrize() public view returns(uint256){
        return(thirdPrize);
    }

    function getPlayerTickets() public view returns(string memory){
        string memory playerTickets;
        for(uint256 i = 0; i < tickets[msg.sender].length; i++){
            playerTickets = append(playerTickets, append(" Ticket nr. ", append(uint2str(i + 1), ": ")));
            for(uint256 j = 0; j < 6; j++){
                playerTickets = append(playerTickets, append(uint2str(tickets[msg.sender][i][j]), ", "));
            }
        }
        return(playerTickets);
    }

    function getPrizePool() public view returns(uint256 _prizePool){
        return(weekPrize);
    }

    // Internal

    function isInList(address[] memory _checkList, address _list) internal pure returns (bool) {
        for(uint i = 0; i < _checkList.length; i++) {
            if(_checkList[i] == _list) {return true;}
        }
        return false;
    }

    function chooseWinningNumbers() internal {
        for (uint256 i = 0; i < 6; i++) {
            drawnNumbers[i] = expand(uint256(randomResult), 6)[i];
        }
    }

    function setPrizes() internal {     // ************************** de modificat premiul pe adresa castigatoare *************
        firstPrize = (address(this).balance + (weekPrize * 34 / 100) - totalGameFee) / firstPrizeWinners;
        secondPrize = (weekPrize * 33 / 100) / secondPrizeWinners;
        thirdPrize = (weekPrize * 33 / 100) / thirdPrizeWinners;
    }
    
    // @dev Converts a `uint256` to its ASCII `string` decimal representation.
    function uint2str(uint256 value) internal pure returns (string memory) {
        // Inspired by OraclizeAPI's implementation - MIT licence
        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }

    function append(string memory a, string memory b) internal pure returns(string memory) {
        return string(abi.encodePacked(a, b));
    }

    function payPrizes() public payable onlyOwner {

    }

    // Only Owner

    function checkWinningTickets() internal {
        uint[] memory correctNumbers;
        for(uint t = 0; t <= tickets[msg.sender].length; t++) {
            uint countCorrectNumbers = 0;
            for(uint i = 0; i < 6; i++) {
                for(uint j = 0; j < 6; j++) {
                    if(tickets[msg.sender][t][i] == drawnNumbers[j]) {
                        correctNumbers[countCorrectNumbers] = tickets[msg.sender][t][i];
                        countCorrectNumbers++;
                    }
                }
            }
            if(countCorrectNumbers == 6){
                firstPrizeWinners ++;
            }
            if(countCorrectNumbers == 5){
                secondPrizeWinners ++;
            }
            if(countCorrectNumbers == 4){
                thirdPrizeWinners ++;
            }
        } 
    }

    function runLottery() public onlyOwner {
        setPrizes();
        chooseWinningNumbers();
        checkWinningTickets();
    }

    function setGamePrice(uint _gamePrice) public onlyOwner {
        gamePrice = _gamePrice;
    }

    function setGameFee(uint _gameFee) public onlyOwner {
        gameFee = _gameFee;
    }

    function pause(bool _state) public onlyOwner {
        gamePaused = _state;
    }

    function feeWithdraw() public payable onlyOwner {
        require(totalGameFee > 0);
        uint gameFeeAmount = totalGameFee;
        totalGameFee = 0;
        (bool os, ) = payable(owner()).call{value: gameFeeAmount}("");
        require(os);
    }
}
